import*as t from"three";class e{curve;radius;tilt;static UvPresets=[(t,e)=>[0,t/e,1,t/e],(t,e)=>[t/e,1,t/e,0],(t,e)=>[1,1-t/e,0,1-t/e],(t,e)=>[1-t/e,0,1-t/e,1]];constructor(t,e=1,o=0){this.curve=t,this.radius=e,this.tilt=o}computeFrames(e){const o=new t.Vector3,s=new t.Vector3,r=new t.Vector3,i=new t.Vector3,n=new t.Vector3,l=new t.Vector3,a=new t.Vector3,c=new t.Vector3,h=[],u=this.tilt instanceof Function?this.tilt:()=>this.tilt,y=(t,e)=>{h[t]=[],h[t][0]=s.clone(),h[t][1]=r.clone(),h[t][2]=o.clone(),h[t][3]=this.curve.getPointAt(t/e);const i=u(t,e);i&&h[t][0].applyAxisAngle(o,i),i&&h[t][1].applyAxisAngle(o,i)};this.curve.getTangentAt(0,o),c.set(Math.abs(o.x),Math.abs(o.y),Math.abs(o.z)),a.set(1,0,0),c.y<=c.x?c.z<=c.y?a.set(0,0,1):a.set(0,1,0):c.z<=c.x&&a.set(0,0,1),c.crossVectors(o,a).normalize(),s.crossVectors(o,c),r.crossVectors(o,s),y(0,e);for(let t=1,a=NaN;t<=e;++t)a=t/e,this.curve.getTangentAt(a,i),n.copy(s),c.crossVectors(o,i).length()>Number.EPSILON&&n.applyAxisAngle(c.normalize(),Math.acos(Math.max(-1,Math.min(1,o.dot(i))))),l.crossVectors(i,n),o.copy(i),r.copy(l),s.copy(n),y(t,e);return h}}class o extends t.BufferGeometry{constructor(t,e,o){super(),!Array.isArray(e)&&(e=[e]),this.#compute(t,e[0],e[1]??e[0],e[2]??0,o)}#compute(e,o,s,r,i){o=Math.max(1,0|o),s=Math.max(1,Math.min(o,0|s)),r=(0|r)%o+ +(r<0)*o;const n=(()=>{const t=r+s;return t<=o?[[r,t,0]]:[[r,o,0],[0,t-o,o-r+1]]})(),l=e.computeFrames(o),a=s+n.length,c=new Float32Array(6*a),h=i?new Float32Array(4*a):null,u=[],y=e.radius instanceof Function?e.radius:()=>e.radius,p=new t.Vector3,m=new t.Vector3;for(const[t,e,r]of n){const n=l.slice(t,e+1);for(const[e,[l,,,a]]of n.entries()){const x=y(t+e,o);p.copy(l).multiplyScalar(x).add(a),m.copy(l).multiplyScalar(-x).add(a),c.set([p.x,p.y,p.z,m.x,m.y,m.z],6*(e+r));const g=2*(e+r);e<n.length-1&&u.push(g,g+1,g+2,g+2,g+1,g+3),i&&h&&h.set(r?i(e+r,s+1):i(e,s),4*(e+r))}}this.attributes.position=new t.BufferAttribute(c,3),h&&(this.attributes.uv=new t.BufferAttribute(h,2)),this.setIndex(u),this.computeVertexNormals()}}class s extends t.LineSegments{strip;segments;length;xColor;yColor;zColor;constructor(e,o,s=1,r=16711680,i=65280,n=255){super(new t.BufferGeometry,new t.LineBasicMaterial({vertexColors:!0})),this.strip=e,this.segments=o,this.length=s,this.type="StripHelper",this.xColor=new t.Color(r),this.yColor=new t.Color(i),this.zColor=new t.Color(n),this.update()}update(){const e=Math.max(1,0|this.segments),o=Math.max(0,this.length),s=this.strip.computeFrames(e),r=new Float32Array(18*s.length),i=new Float32Array(18*s.length);this.geometry.dispose(),this.geometry.attributes.position=new t.BufferAttribute(r,3),this.geometry.attributes.color=new t.BufferAttribute(i,3);for(const[t,[e,n,l,a]]of s.entries())e.multiplyScalar(o).add(a),n.multiplyScalar(o).add(a),l.multiplyScalar(o).add(a),r.set([a.x,a.y,a.z,e.x,e.y,e.z,a.x,a.y,a.z,n.x,n.y,n.z,a.x,a.y,a.z,l.x,l.y,l.z],18*t),i.set([this.xColor.r,this.xColor.g,this.xColor.b,this.xColor.r,this.xColor.g,this.xColor.b,this.yColor.r,this.yColor.g,this.yColor.b,this.yColor.r,this.yColor.g,this.yColor.b,this.zColor.r,this.zColor.g,this.zColor.b,this.zColor.r,this.zColor.g,this.zColor.b],18*t)}}export{e as Strip,o as StripGeometry,s as StripHelper};
