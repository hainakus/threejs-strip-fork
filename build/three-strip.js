class t extends Error{constructor(){super("Buffer geometry has been disposed internally")}}class s extends Error{constructor(){super("Missing threejs lib; please assign it to `Strip.THREE`")}}function e(e){if(!e)throw new s;return function(s){return class extends s.LineSegments{#strip;#len;#c0;#c1;#c2;#nFrm;#colorNeedsUpdate;constructor(e,i=1,r="#ff0000",h="#00ff00",o="#0000ff"){if(!e.geometry||!e.frames)throw new t;super(new s.BufferGeometry,new s.LineBasicMaterial({vertexColors:!0})),this.#strip=e,this.#len=i,this.#c0=new s.Color(r),this.#c1=new s.Color(h),this.#c2=new s.Color(o),this.#nFrm=-1,this.#colorNeedsUpdate=!0,this.update()}setColors(t=this.#c0,e=this.#c1,i=this.#c2){t=new s.Color(t),e=new s.Color(e),i=new s.Color(i),this.#c0.equals(t)&&this.#c1.equals(e)&&this.#c2.equals(i)||(this.#c0=t,this.#c1=e,this.#c2=i,this.#colorNeedsUpdate=!0,this.update())}setLength(t){this.#len=t,this.update()}update(){if(this.geometry.dispose(),!this.#strip.geometry||!this.#strip.frames)return;this.#strip.frames.length!==this.#nFrm&&(this.geometry.setAttribute("color",new s.Float32BufferAttribute(18*this.#strip.frames.length,3)),this.#nFrm=this.#strip.frames.length,this.#colorNeedsUpdate=!0);const t=this.geometry.getAttribute("color"),e=this.#strip.curve.getSpacedPoints(this.#strip.segment),i=[];for(const[s,r]of this.#strip.frames.entries())i.push(e[s],r[1].clone().multiplyScalar(this.#len).add(e[s]),e[s],r[2].clone().multiplyScalar(this.#len).add(e[s]),e[s],r[0].clone().multiplyScalar(this.#len).add(e[s])),this.#colorNeedsUpdate&&t.array.set([this.#c0.r,this.#c0.g,this.#c0.b,this.#c0.r,this.#c0.g,this.#c0.b,this.#c1.r,this.#c1.g,this.#c1.b,this.#c1.r,this.#c1.g,this.#c1.b,this.#c2.r,this.#c2.g,this.#c2.b,this.#c2.r,this.#c2.g,this.#c2.b],18*s);this.geometry.setFromPoints(i),this.#colorNeedsUpdate&&(this.geometry.attributes.color.needsUpdate=!0),this.#colorNeedsUpdate=!1}}}(e)}class i{static#THREE=null;static#Helper;static get THREE(){return i.#THREE}static set THREE(t){i.#THREE=t,i.#Helper=e(t)}static get Helper(){if(!this.#Helper)throw new s;return this.#Helper}static UvFns=[(t,s)=>[0,t/s,1,t/s],(t,s)=>[t/s,1,t/s,0],(t,s)=>[1,1-t/s,0,1-t/s],(t,s)=>[1-t/s,0,1-t/s,1]];#crv;#seg;#r=.5;#tilt=0;#uv;#mrps;#geom;#frms;#rFn=()=>.5;#tiltFn=()=>0;constructor(t,e,r=.5,h=0,o=null){if(!i.#THREE)throw new s;this.#crv=t,this.#seg=e,this.#setR(r),this.#setTilt(h),this.#uv=o,this.#mrps=null,this.#geom=null,this.#frms=null,this.#geom=new i.#THREE.BufferGeometry,this.#update(!0,!0,!0,!0,!!this.#uv,!1)}#setR(t){this.#r=t,this.#rFn="function"==typeof t?t:()=>t}#setTilt(t){this.#tilt=t,this.#tiltFn="function"==typeof t?t:()=>t}get curve(){return this.#crv}set curve(t){this.#crv=t,this.#update(!0,!1,!1,!1,!1,!1)}get segment(){return this.#seg}set segment(t){this.#seg=Math.max(1,0|t),this.#update(!1,!0,!1,!1,!1,!1)}get radius(){return this.#r}set radius(t){t!==this.#r&&(this.#setR(t),this.#update(!1,!1,!0,!1,!1,!1))}get tilt(){return this.#tilt}set tilt(t){t!==this.#tilt&&(this.#setTilt(t),this.#update(!1,!1,!1,!0,!1,!1))}get uv(){return this.#uv}set uv(t){this.#uv!==t&&(this.#uv=t,t?this.#update(!1,!1,!1,!1,!0,!1):this.#geom?.deleteAttribute("uv"))}get geometry(){return this.#geom}get frames(){return this.#frms}setMorphs(t){t?(this.#mrps=t,this.#update(!1,!1,!1,!1,!1,!0)):this.#geom&&(this.#geom.morphAttributes.position=[],this.#geom.morphAttributes.normal=[])}setProps(t=this.#crv,s=this.#seg,e=this.#r,i=this.#tilt,r=this.#uv){const h=this.#crv!==t;h&&(this.#crv=t);const o=this.#seg!==s;o&&(this.#seg=s);const n=this.#r!==e;n&&this.#setR(e);const l=this.#tilt!==i;l&&this.#setTilt(i);const u=this.#uv!==r&&!!r;r||this.geometry?.deleteAttribute("uv"),this.#uv=r,(h||o||n||l||u)&&this.#update(h,o,n,l,u,!1)}dispose(){this.#geom?.dispose(),this.#geom=null,this.#frms=null}#update(t,s,e,r,h,o){if(!this.#geom)return;const n=i.THREE;this.#geom.dispose();const l=this.#geom,u=t||s||e||r,a=t||s||r,c=h||s,p=s,g=s||o,m=a||s||!this.#frms?this.#frms=[]:this.#frms;u&&l.setAttribute("position",new n.Float32BufferAttribute(12*this.#seg,3));const d=l.getAttribute("position");a&&l.setAttribute("normal",new n.Float32BufferAttribute(12*this.#seg,3));const f=l.getAttribute("normal");(s||c&&!l.hasAttribute("uv"))&&l.setAttribute("uv",new n.Float32BufferAttribute(8*this.#seg,2));const b=l.getAttribute("uv"),y=p?[]:null,v=this.#crv.getSpacedPoints(this.#seg),{tangents:A,binormals:w,normals:E}=this.#crv.computeFrenetFrames(this.#seg),F=this.#seg,x=new n.Vector3,H=new n.Vector3;for(let t=0,s=-1,e=NaN,i=NaN;t<=F;++t)(u||a)&&(e=this.#rFn(t,F),i=this.#tiltFn(t,F),m[t]??=[x,x,x],m[t][0]=A[t],m[t][1]=i?E[t].applyAxisAngle(A[t],i):E[t],m[t][2]=i?w[t].applyAxisAngle(A[t],i):w[t]),u&&(x.copy(m[t][1]).multiplyScalar(e).add(v[t]),H.copy(m[t][1]).multiplyScalar(-e).add(v[t]),d.array.set([x.x,x.y,x.z,H.x,H.y,H.z],6*t)),c&&this.#uv&&b.array.set(this.#uv(t,F),4*t),p&&t<F&&y.push(s=2*t,s+1,s+2,s+2,s+1,s+3);if(p&&l.setIndex(y),a&&this.#seg>1)for(let t=0;t<m.length;++t)0===t||t===m.length-1?f.array.set([m[t][2].x,m[t][2].y,m[t][2].z,m[t][2].x,m[t][2].y,m[t][2].z],6*t):(x.addVectors(m[t-1][2],m[t][2]).add(m[t+1][2]).divideScalar(3),f.array.set([x.x,x.y,x.z,x.x,x.y,x.z],6*t));if(g&&this.#mrps){l.morphAttributes.position=[],l.morphAttributes.normal=[];for(const{curve:t,radius:s,tilt:e}of this.#mrps){const{geometry:r}=new i(t,this.#seg,s??.5,e??0);l.morphAttributes.position.push(r.getAttribute("position")),l.morphAttributes.normal.push(r.getAttribute("normal"))}}u&&(l.attributes.position.needsUpdate=!0),a&&(l.attributes.normal.needsUpdate=!0),c&&(l.attributes.uv.needsUpdate=!0),p&&(l.index.needsUpdate=!0)}}export{i as Strip};
