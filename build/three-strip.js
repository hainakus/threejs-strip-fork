class t extends Error{constructor(){super("Buffer geometry has been disposed internally")}}class s extends Error{constructor(){super("Missing threejs lib; please assign it to `Strip.THREE`")}}class e{static#THREE=null;static#Helper;static#Crv;static get THREE(){return e.#THREE}static set THREE(s){var i;e.#THREE=s,s?(e.#Helper=(i=s,class extends i.LineSegments{#strip;#len;#c0;#c1;#c2;constructor(s,e=1,r="#ff0000",o="#00ff00",h="#0000ff"){if(!s.geometry||!s.frames)throw new t;super(new i.BufferGeometry,new i.LineBasicMaterial({vertexColors:!0})),this.#strip=s,this.#len=e,this.#c0=new i.Color(r),this.#c1=new i.Color(o),this.#c2=new i.Color(h),this.update()}setColors(t=this.#c0,s=this.#c1,e=this.#c2){t=new i.Color(t),s=new i.Color(s),e=new i.Color(e),this.#c0.equals(t)&&this.#c1.equals(s)&&this.#c2.equals(e)||(this.#c0=t,this.#c1=s,this.#c2=e,this.update())}setLength(t){this.#len=t,this.update()}update(){if(this.geometry.dispose(),!this.#strip.geometry||!this.#strip.frames)return this.geometry.deleteAttribute("color"),void this.geometry.deleteAttribute("position");const t=this.#strip.frames,s=t.length,e=new i.Float32BufferAttribute(18*s,3);this.geometry.setAttribute("color",e);const r=new i.Float32BufferAttribute(18*s,3);this.geometry.setAttribute("position",r);const o=new i.Vector3,h=new i.Vector3,n=new i.Vector3,c=new i.Vector3,l=this.#strip.geometry.attributes.position;for(let i=0,a=-1;i<s;++i)o.set(l.getX(a=2*i),l.getY(a),l.getZ(a)),h.set(l.getX(++a),l.getY(a),l.getZ(a)),c.addVectors(o,h).multiplyScalar(.5),o.copy(t[i][1]).multiplyScalar(this.#len).add(c),h.copy(t[i][2]).multiplyScalar(this.#len).add(c),n.copy(t[i][0]).multiplyScalar(this.#len).add(c),r.array.set([c.x,c.y,c.z,o.x,o.y,o.z,c.x,c.y,c.z,h.x,h.y,h.z,c.x,c.y,c.z,n.x,n.y,n.z],18*i),e.array.set([this.#c0.r,this.#c0.g,this.#c0.b,this.#c0.r,this.#c0.g,this.#c0.b,this.#c1.r,this.#c1.g,this.#c1.b,this.#c1.r,this.#c1.g,this.#c1.b,this.#c2.r,this.#c2.g,this.#c2.b,this.#c2.r,this.#c2.g,this.#c2.b],18*i)}dispose(){this.update(),Array.isArray(this.material)?this.material.forEach((t=>t.dispose())):this.material.dispose()}}),e.#Crv=function(t){return class extends t.Curve{constructor(){super()}forEachTBN(s,e,i){const r=new t.Vector3,o=new t.Vector3,h=new t.Vector3,n=new t.Vector3,c=new t.Vector3,l=new t.Vector3,a=new t.Vector3,u=new t.Vector3;let p=e(0,s);this.getTangentAt(p,r),u.set(Math.abs(r.x),Math.abs(r.x),Math.abs(r.z)),a.set(1,0,0),u.y<=u.x?u.z<=u.y?a.set(0,0,1):a.set(0,1,0):u.z<=u.x&&a.set(0,0,1),u.crossVectors(r,a).normalize(),h.crossVectors(r,u),o.crossVectors(r,h),this.getPointAt(p,u),i(0,s,[r.clone(),o.clone(),h.clone()],u);for(let t=1;t<=s;t++)p=e(t,s),this.getTangentAt(p,n),l.copy(h),c.copy(o),u.crossVectors(r,n),u.length()>Number.EPSILON&&(u.normalize(),l.applyAxisAngle(u,Math.acos((g=r.dot(n))<-1?-1:g>1?1:g))),c.crossVectors(n,l),this.getPointAt(p,u),i(t,s,[n.clone(),c.clone(),l.clone()],u),r.copy(n),h.copy(l),o.copy(c);var g}}}(s)):(e.#Helper=null,e.#Crv=null)}static get Helper(){if(!this.#Helper)throw new s;return this.#Helper}static UvFns=[(t,s)=>[0,t/s,1,t/s],(t,s)=>[t/s,1,t/s,0],(t,s)=>[1,1-t/s,0,1-t/s],(t,s)=>[1-t/s,0,1-t/s,1]];#crv;#seg;#r=.5;#tilt=0;#uv;#mrps;#geom;#frms;#rFn=()=>.5;#tiltFn=()=>0;#disposed=!1;constructor(t,i,r=.5,o=0,h=null){if(!e.#THREE)throw new s;this.#crv=t,this.#seg=i,this.#setR(r),this.#setTilt(o),this.#uv=h,this.#mrps=null,this.#geom=null,this.#frms=null,this.#geom=new e.#THREE.BufferGeometry,this.#update()}#setR(t){this.#r=t,this.#rFn="function"==typeof t?t:isNaN(t)?null:()=>t}#setTilt(t){this.#tilt=t,this.#tiltFn="function"==typeof t?t:isNaN(t)?null:()=>t}get curve(){return this.#crv}set curve(t){this.#crv=t,this.#update()}get segment(){return this.#seg}set segment(t){this.#seg=Math.max(1,0|t),this.#update()}get radius(){return this.#r}set radius(t){t!==this.#r&&(this.#setR(t),this.#update())}get tilt(){return this.#tilt}set tilt(t){t!==this.#tilt&&(this.#setTilt(t),this.#update())}get uv(){return this.#uv}set uv(t){this.#uv!==t&&(this.#uv=t,t?this.#update():this.#geom?.deleteAttribute("uv"))}get geometry(){return this.#geom}get frames(){return this.#frms}setMorphs(t){this.#mrps=t,this.#update()}setProps(t=this.#crv,s=this.#seg,e=this.#r,i=this.#tilt,r=this.#uv){const o=this.#crv!==t;o&&(this.#crv=t);const h=this.#seg!==s;h&&(this.#seg=s);const n=this.#r!==e;n&&this.#setR(e);const c=this.#tilt!==i;c&&this.#setTilt(i);const l=this.#uv!==r&&!!r;r||this.geometry?.deleteAttribute("uv"),this.#uv=r,(o||h||n||c||l)&&this.#update()}dispose(){this.#disposed||(this.#crv=null,this.#seg=1,this.#setR(NaN),this.#setTilt(NaN),this.#uv=null,this.#mrps=null,this.#geom?.dispose(),this.#geom=null,this.#frms=null,this.#disposed=!0)}get isDisposed(){return this.#disposed}#update(){if(!e.THREE||this.isDisposed)return;this.#geom.dispose();const t=e.THREE,s=this.#geom,i=new t.Float32BufferAttribute(6*(this.#seg+1),3);s.setAttribute("position",i);const r=new t.Float32BufferAttribute(6*(this.#seg+1),3);s.setAttribute("normal",r);const o=[];this.#uv&&s.setAttribute("uv",new t.Float32BufferAttribute(4*(this.#seg+1),2));const h=s.getAttribute("uv");if(s.morphAttributes.position=[],s.morphAttributes.normal=[],!this.#crv)return this.#geom=null,void(this.#frms=null);this.#frms??=[],this.#frms.length=this.#seg;const n=this.#frms,c=new t.Vector3,l=new t.Vector3;let a=-1,u=NaN,p=NaN;if(e.#Crv.prototype.forEachTBN.call(this.#crv,this.#seg,((t,s)=>t/s),((t,s,[e,r,g],d)=>{u=this.#rFn(t,s),p=this.#tiltFn(t,s),n[t]??=[c,c,c],n[t][0]=e,n[t][1]=p?g.applyAxisAngle(e,p):g,n[t][2]=p?r.applyAxisAngle(e,p):r,c.copy(n[t][1]).multiplyScalar(u).add(d),l.copy(n[t][1]).multiplyScalar(-u).add(d),i.array.set([c.x,c.y,c.z,l.x,l.y,l.z],6*t),t<s&&o.push(a=2*t,a+1,a+2,a+2,a+1,a+3),this.#uv&&h.array.set(this.#uv(t,s),4*t)})),s.setIndex(o),1===this.#seg)c.addVectors(n[0][2],n[1][2]).divideScalar(2),r.array.set([c.x,c.y,c.z,c.x,c.y,c.z,c.x,c.y,c.z,c.x,c.y,c.z]);else for(const[t,s]of n.entries())0===t||t===n.length-1?r.array.set([s[2].x,s[2].y,s[2].z,s[2].x,s[2].y,s[2].z],6*t):(c.addVectors(n[t-1][2],s[2]).add(n[t+1][2]).divideScalar(3),r.array.set([c.x,c.y,c.z,c.x,c.y,c.z],6*t));if(this.#mrps)for(const{curve:t,radius:i,tilt:r}of this.#mrps){const{geometry:o}=new e(t,this.#seg,i??.5,r??0);s.morphAttributes.position.push(o.getAttribute("position")),s.morphAttributes.normal.push(o.getAttribute("normal"))}}}export{e as Strip};
