import*as t from"three";class s{curve;radius;tilt;static UvPresets=[(t,s)=>[0,t/s,1,t/s],(t,s)=>[t/s,1,t/s,0],(t,s)=>[1,1-t/s,0,1-t/s],(t,s)=>[1-t/s,0,1-t/s,1]];constructor(t,s=1,e=0){this.curve=t,this.radius=s,this.tilt=e}computeFrames(s){const e=new t.Vector3,r=new t.Vector3,o=new t.Vector3,i=new t.Vector3,n=new t.Vector3,l=new t.Vector3,a=new t.Vector3,h=new t.Vector3,c=[],u=this.tilt instanceof Function?this.tilt:()=>this.tilt,p=(t,s)=>{c[t]=[],c[t][0]=r.clone(),c[t][1]=o.clone(),c[t][2]=e.clone(),c[t][3]=this.curve.getPointAt(t/s);const i=u(t,s);i&&c[t][0].applyAxisAngle(e,i),i&&c[t][1].applyAxisAngle(e,i)};this.curve.getTangentAt(0,e),h.set(Math.abs(e.x),Math.abs(e.y),Math.abs(e.z)),a.set(1,0,0),h.y<=h.x?h.z<=h.y?a.set(0,0,1):a.set(0,1,0):h.z<=h.x&&a.set(0,0,1),h.crossVectors(e,a).normalize(),o.crossVectors(e,h),r.crossVectors(e,o),p(0,s);for(let t=1,a=NaN;t<=s;++t)a=t/s,this.curve.getTangentAt(a,i),l.copy(o),h.crossVectors(e,i).length()>Number.EPSILON&&l.applyAxisAngle(h.normalize(),Math.acos(Math.max(-1,Math.min(1,e.dot(i))))),n.crossVectors(i,l),e.copy(i),o.copy(l),r.copy(n),p(t,s);return c}}class e extends t.BufferGeometry{strip;segments;uvFn;constructor(t,s,e){super(),this.strip=t,this.segments=s,this.uvFn=e,!Array.isArray(s)&&(s=[s]),this.#compute(s[0],s[1]??s[0],s[2]??0)}#compute(s,e,r){s=Math.max(1,0|s),e=Math.max(1,Math.min(s,0|e)),r=(0|r)%s+ +(r<0)*s;const o=(()=>{const t=r+e;return t<=s?[[r,t,0]]:[[r,s,0],[0,t-s,s-r+1]]})(),i=this.strip.computeFrames(s),n=e+o.length,l=new Float32Array(6*n),a=this.uvFn?new Float32Array(4*n):null,h=[],c=this.strip.radius instanceof Function?this.strip.radius:()=>this.strip.radius,u=new t.Vector3,p=new t.Vector3;for(const[t,r,n]of o){const o=i.slice(t,r+1);for(const[r,[i,,,y]]of o.entries()){const m=c(t+r,s);u.copy(i).multiplyScalar(m).add(y),p.copy(i).multiplyScalar(-m).add(y),l.set([u.x,u.y,u.z,p.x,p.y,p.z],6*(r+n));const x=2*(r+n);r<o.length-1&&h.push(x,x+1,x+2,x+2,x+1,x+3),this.uvFn&&a&&a.set(n?this.uvFn(r+n,e+1):this.uvFn(r,e),4*(r+n))}}this.attributes.position=new t.BufferAttribute(l,3),a&&(this.attributes.uv=new t.BufferAttribute(a,2)),this.setIndex(h),this.computeVertexNormals()}}class r extends t.LineSegments{strip;segments;length;xColor;yColor;zColor;constructor(s,e,r=1,o=16711680,i=65280,n=255){super(new t.BufferGeometry,new t.LineBasicMaterial({vertexColors:!0})),this.strip=s,this.segments=e,this.length=r,this.type="StripHelper",this.xColor=new t.Color(o),this.yColor=new t.Color(i),this.zColor=new t.Color(n),this.update()}update(){const s=Math.max(1,0|this.segments),e=Math.max(0,this.length),r=this.strip.computeFrames(s),o=new Float32Array(18*r.length),i=new Float32Array(18*r.length);this.geometry.dispose(),this.geometry.attributes.position=new t.BufferAttribute(o,3),this.geometry.attributes.color=new t.BufferAttribute(i,3);for(const[t,[s,n,l,a]]of r.entries())s.multiplyScalar(e).add(a),n.multiplyScalar(e).add(a),l.multiplyScalar(e).add(a),o.set([a.x,a.y,a.z,s.x,s.y,s.z,a.x,a.y,a.z,n.x,n.y,n.z,a.x,a.y,a.z,l.x,l.y,l.z],18*t),i.set([this.xColor.r,this.xColor.g,this.xColor.b,this.xColor.r,this.xColor.g,this.xColor.b,this.yColor.r,this.yColor.g,this.yColor.b,this.yColor.r,this.yColor.g,this.yColor.b,this.zColor.r,this.zColor.g,this.zColor.b,this.zColor.r,this.zColor.g,this.zColor.b],18*t)}}export{s as Strip,e as StripGeometry,r as StripHelper};
