class t extends Error{constructor(){super("Buffer geometry has been disposed internally")}}class s extends Error{constructor(){super("Missing threejs lib; please assign it to `Strip.THREE`")}}class e{static#THREE=null;static#Helper;static#Crv;static get THREE(){return e.#THREE}static set THREE(s){var i;e.#THREE=s,s?(e.#Helper=(i=s,class extends i.LineSegments{#strip=null;#len=NaN;#c0=null;#c1=null;#c2=null;#disposed=!1;constructor(s,e=1,r="#ff0000",h="#00ff00",o="#0000ff"){if(s.isDisposed)throw new t;super(new i.BufferGeometry,new i.LineBasicMaterial({vertexColors:!0})),this.type="StripHelper",this.#strip=s,this.#len=e,this.#c0=new i.Color(r),this.#c1=new i.Color(h),this.#c2=new i.Color(o),this.#disposed=!1,this.update()}getColors(){return!this.#disposed&&this.#c0&&this.#c1&&this.#c2?[this.#c0.clone(),this.#c1.clone(),this.#c2.clone()]:[null,null,null]}setColors(t,s,e){!this.#disposed&&this.#c0&&this.#c1&&this.#c2&&(t=new i.Color(t??this.#c0),s=new i.Color(s??this.#c1),e=new i.Color(e??this.#c2),this.#c0.equals(t)&&this.#c1.equals(s)&&this.#c2.equals(e)||(this.#c0=t,this.#c1=s,this.#c2=e,this.update()))}getLength(){return this.#len}setLength(t){this.#disposed||(this.#len=t,this.update())}update(){if(this.geometry.dispose(),this.#disposed||!this.#strip||!this.#c0||!this.#c1||!this.#c2)return;if(this.#strip.isDisposed||!this.#strip.geometry||!this.#strip.frames)return;const t=this.#strip.frames,s=t.length,e=new i.Float32BufferAttribute(18*s,3);this.geometry.setAttribute("color",e);const r=new i.Float32BufferAttribute(18*s,3);this.geometry.setAttribute("position",r);const h=new i.Vector3,o=new i.Vector3,n=new i.Vector3,l=new i.Vector3,c=this.#strip.geometry.attributes.position;for(let i=0,u=-1;i<s;++i)h.set(c.getX(u=2*i),c.getY(u),c.getZ(u)),o.set(c.getX(++u),c.getY(u),c.getZ(u)),l.addVectors(h,o).multiplyScalar(.5),h.copy(t[i][1]).multiplyScalar(this.#len).add(l),o.copy(t[i][2]).multiplyScalar(this.#len).add(l),n.copy(t[i][0]).multiplyScalar(this.#len).add(l),r.array.set([l.x,l.y,l.z,h.x,h.y,h.z,l.x,l.y,l.z,o.x,o.y,o.z,l.x,l.y,l.z,n.x,n.y,n.z],18*i),e.array.set([this.#c0.r,this.#c0.g,this.#c0.b,this.#c0.r,this.#c0.g,this.#c0.b,this.#c1.r,this.#c1.g,this.#c1.b,this.#c1.r,this.#c1.g,this.#c1.b,this.#c2.r,this.#c2.g,this.#c2.b,this.#c2.r,this.#c2.g,this.#c2.b],18*i)}dispose(){this.#disposed||(this.#strip=null,this.#len=NaN,this.#c0=null,this.#c1=null,this.#c2=null,this.geometry.dispose(),Array.isArray(this.material)?this.material.forEach((t=>t.dispose())):this.material.dispose(),this.#disposed=!0)}get isDisposed(){return this.#disposed}}),e.#Crv=function(t){return class extends t.Curve{constructor(){super()}forEachTBN(s,e,i){const r=new t.Vector3,h=new t.Vector3,o=new t.Vector3,n=new t.Vector3,l=new t.Vector3,c=new t.Vector3,u=new t.Vector3,a=new t.Vector3;let p=e(0,s);this.getTangentAt(p,r),a.set(Math.abs(r.x),Math.abs(r.x),Math.abs(r.z)),u.set(1,0,0),a.y<=a.x?a.z<=a.y?u.set(0,0,1):u.set(0,1,0):a.z<=a.x&&u.set(0,0,1),a.crossVectors(r,u).normalize(),o.crossVectors(r,a),h.crossVectors(r,o),this.getPointAt(p,a),i(0,s,[r.clone(),h.clone(),o.clone()],a);for(let t=1;t<=s;t++)p=e(t,s),this.getTangentAt(p,n),c.copy(o),l.copy(h),a.crossVectors(r,n),a.length()>Number.EPSILON&&(a.normalize(),c.applyAxisAngle(a,Math.acos((d=r.dot(n))<-1?-1:d>1?1:d))),l.crossVectors(n,c),this.getPointAt(p,a),i(t,s,[n.clone(),l.clone(),c.clone()],a),r.copy(n),o.copy(c),h.copy(l);var d}}}(s)):(e.#Helper=null,e.#Crv=null)}static get Helper(){if(!this.#Helper)throw new s;return this.#Helper}static UvFns=[(t,s)=>[0,t/s,1,t/s],(t,s)=>[t/s,1,t/s,0],(t,s)=>[1,1-t/s,0,1-t/s],(t,s)=>[1-t/s,0,1-t/s,1]];#crv;#seg;#r=.5;#tilt=0;#uv;#mrps;#geom;#frms;#rFn=()=>.5;#tiltFn=()=>0;#disposed=!1;constructor(t,i,r=.5,h=0,o=null){if(!e.#THREE)throw new s;this.#crv=t,this.#seg=i,this.#setR(r),this.#setTilt(h),this.#uv=o,this.#mrps=null,this.#geom=null,this.#frms=null,this.#geom=new e.#THREE.BufferGeometry,this.#update()}#setR(t){this.#r=t,this.#rFn="function"==typeof t?t:()=>t}#setTilt(t){this.#tilt=t,this.#tiltFn="function"==typeof t?t:()=>t}get curve(){return this.#crv}set curve(t){this.#crv=t,this.#update()}get segment(){return this.#seg}set segment(t){(t=Math.max(1,0|t))!==this.#seg&&(this.#seg=t,this.#update())}get radius(){return this.#r}set radius(t){t!==this.#r&&(this.#setR(t),this.#update())}get tilt(){return this.#tilt}set tilt(t){t!==this.#tilt&&(this.#setTilt(t),this.#update())}get uv(){return this.#uv}set uv(t){t!==this.#uv&&(this.#uv=t,this.#update())}get geometry(){return this.#geom}get frames(){return this.#frms}setMorphs(t){this.#disposed||(this.#mrps=t,this.#update())}setProps(t=this.#crv,s=this.#seg,e=this.#r,i=this.#tilt,r=this.#uv){if(this.#disposed)return;const h=this.#crv!==t||this.#seg!==s||this.#r!==e||this.#tilt!==i||this.uv!==r;this.#crv=t,this.#seg=s,this.#setR(e),this.#setTilt(i),this.#uv=r,h&&this.#update()}dispose(){this.#disposed||(this.#crv=null,this.#seg=NaN,this.#r=NaN,this.#rFn=null,this.#tilt=NaN,this.#tiltFn=null,this.#uv=null,this.#mrps=null,this.#geom?.dispose(),this.#geom=null,this.#frms=null,this.#disposed=!0)}get isDisposed(){return this.#disposed}#update(){if(!e.THREE)return;if(this.#disposed||!this.#geom)return;this.#geom.dispose();const t=e.THREE,s=this.#geom,i=new t.Float32BufferAttribute(6*(this.#seg+1),3);s.setAttribute("position",i);const r=new t.Float32BufferAttribute(6*(this.#seg+1),3);s.setAttribute("normal",r);const h=[];this.#uv&&s.setAttribute("uv",new t.Float32BufferAttribute(4*(this.#seg+1),2));const o=s.getAttribute("uv");if(s.morphAttributes.position=[],s.morphAttributes.normal=[],!this.#crv)return this.#geom=null,void(this.#frms=null);this.#frms??=[],this.#frms.length=this.#seg;const n=this.#frms,l=new t.Vector3,c=new t.Vector3;let u=-1,a=NaN,p=NaN;if(e.#Crv.prototype.forEachTBN.call(this.#crv,this.#seg,((t,s)=>t/s),((t,s,[e,r,d],g)=>{a=this.#rFn(t,s),p=this.#tiltFn(t,s),n[t]??=[l,l,l],n[t][0]=e,n[t][1]=p?d.applyAxisAngle(e,p):d,n[t][2]=p?r.applyAxisAngle(e,p):r,l.copy(n[t][1]).multiplyScalar(a).add(g),c.copy(n[t][1]).multiplyScalar(-a).add(g),i.array.set([l.x,l.y,l.z,c.x,c.y,c.z],6*t),t<s&&h.push(u=2*t,u+1,u+2,u+2,u+1,u+3),this.#uv&&o.array.set(this.#uv(t,s),4*t)})),s.setIndex(h),1===this.#seg)l.addVectors(n[0][2],n[1][2]).divideScalar(2),r.array.set([l.x,l.y,l.z,l.x,l.y,l.z,l.x,l.y,l.z,l.x,l.y,l.z]);else for(const[t,s]of n.entries())0===t||t===n.length-1?r.array.set([s[2].x,s[2].y,s[2].z,s[2].x,s[2].y,s[2].z],6*t):(l.addVectors(n[t-1][2],s[2]).add(n[t+1][2]).divideScalar(3),r.array.set([l.x,l.y,l.z,l.x,l.y,l.z],6*t));if(this.#mrps)for(const{curve:t,radius:i,tilt:r}of this.#mrps){const{geometry:h}=new e(t,this.#seg,i,r);s.morphAttributes.position.push(h.getAttribute("position")),s.morphAttributes.normal.push(h.getAttribute("normal"))}}}export{e as Strip};
