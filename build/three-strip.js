class t extends Error{constructor(){super("Buffer geometry has been disposed internally")}}class s extends Error{constructor(){super("Missing threejs lib; please assign it to `Strip.THREE`")}}function e(t,s,e,i,r,o){for(let h=0;h<e-s;++h){const e=2*t*(s+h),n=i.slice(e,e+t),l=i.slice(e+t,e+2*t),c=i.slice(e+2*t,e+3*t),u=i.slice(e+3*t,e+4*t);r.set([...n,...l,...c,...c,...l,...u],6*t*(h+o))}}class i{static#THREE=null;static#Helper;static#Crv;static#Anim;static get THREE(){return i.#THREE}static set THREE(s){var r;i.#THREE=s,s?(i.#Helper=(r=s,class extends r.LineSegments{#strip=null;#len=NaN;#c0=null;#c1=null;#c2=null;#disposed=!1;constructor(s,e=1,i="#ff0000",o="#00ff00",h="#0000ff"){if(s.isDisposed)throw new t;super(new r.BufferGeometry,new r.LineBasicMaterial({vertexColors:!0})),this.type="StripHelper",this.#strip=s,this.#len=e,this.#c0=new r.Color(i),this.#c1=new r.Color(o),this.#c2=new r.Color(h),this.#disposed=!1,this.update()}getColors(){return!this.#disposed&&this.#c0&&this.#c1&&this.#c2?[this.#c0.clone(),this.#c1.clone(),this.#c2.clone()]:[null,null,null]}setColors(t,s,e){!this.#disposed&&this.#c0&&this.#c1&&this.#c2&&(t=new r.Color(t??this.#c0),s=new r.Color(s??this.#c1),e=new r.Color(e??this.#c2),this.#c0.equals(t)&&this.#c1.equals(s)&&this.#c2.equals(e)||(this.#c0=t,this.#c1=s,this.#c2=e,this.update()))}getLength(){return this.#len}setLength(t){this.#disposed||(this.#len=t,this.update())}update(){if(this.geometry.dispose(),this.#disposed||!this.#strip||!this.#c0||!this.#c1||!this.#c2)return;if(this.#strip.isDisposed||!this.#strip.geometry||!this.#strip.frames)return;const t=this.#strip.frames,s=t.length,e=new r.Float32BufferAttribute(18*s,3);this.geometry.setAttribute("color",e);const i=new r.Float32BufferAttribute(18*s,3);this.geometry.setAttribute("position",i);const o=new r.Vector3,h=new r.Vector3,n=new r.Vector3,l=new r.Vector3,c=this.#strip.geometry.attributes.position;for(let r=0,u=-1;r<s;++r)o.set(c.getX(u=2*r),c.getY(u),c.getZ(u)),h.set(c.getX(++u),c.getY(u),c.getZ(u)),l.addVectors(o,h).multiplyScalar(.5),o.copy(t[r][1]).multiplyScalar(this.#len).add(l),h.copy(t[r][2]).multiplyScalar(this.#len).add(l),n.copy(t[r][0]).multiplyScalar(this.#len).add(l),i.array.set([l.x,l.y,l.z,o.x,o.y,o.z,l.x,l.y,l.z,h.x,h.y,h.z,l.x,l.y,l.z,n.x,n.y,n.z],18*r),e.array.set([this.#c0.r,this.#c0.g,this.#c0.b,this.#c0.r,this.#c0.g,this.#c0.b,this.#c1.r,this.#c1.g,this.#c1.b,this.#c1.r,this.#c1.g,this.#c1.b,this.#c2.r,this.#c2.g,this.#c2.b,this.#c2.r,this.#c2.g,this.#c2.b],18*r)}dispose(){this.#disposed||(this.#strip=null,this.#len=NaN,this.#c0=null,this.#c1=null,this.#c2=null,this.geometry.dispose(),Array.isArray(this.material)?this.material.forEach((t=>t.dispose())):this.material.dispose(),this.#disposed=!0)}get isDisposed(){return this.#disposed}}),i.#Crv=function(t){return class extends t.Curve{constructor(){super()}forEachTBN(s,e,i){const r=new t.Vector3,o=new t.Vector3,h=new t.Vector3,n=new t.Vector3,l=new t.Vector3,c=new t.Vector3,u=new t.Vector3,a=new t.Vector3;let p=e(0,s);this.getTangentAt(p,r),a.set(Math.abs(r.x),Math.abs(r.x),Math.abs(r.z)),u.set(1,0,0),a.y<=a.x?a.z<=a.y?u.set(0,0,1):u.set(0,1,0):a.z<=a.x&&u.set(0,0,1),a.crossVectors(r,u).normalize(),h.crossVectors(r,a),o.crossVectors(r,h),this.getPointAt(p,a),i(0,s,[r.clone(),o.clone(),h.clone()],a);for(let t=1;t<=s;t++)p=e(t,s),this.getTangentAt(p,n),c.copy(h),l.copy(o),a.crossVectors(r,n),a.length()>Number.EPSILON&&(a.normalize(),c.applyAxisAngle(a,Math.acos((g=r.dot(n))<-1?-1:g>1?1:g))),l.crossVectors(n,c),this.getPointAt(p,a),i(t,s,[n.clone(),l.clone(),c.clone()],a),r.copy(n),h.copy(c),o.copy(l);var g}}}(s),i.#Anim=function(s){return class{#strip;#seg;#dur;#geom;#clip;constructor(s,e,i){if(s.isDisposed)throw new t;this.#strip=s,this.#seg=0|Math.max(1,Math.min(s.segment,e)),this.#dur=i,this.#geom=null,this.#clip=null,this.#compute()}#compute(){if(!this.#strip)return;const t=this.#seg,i=this.#strip,r=new s.BufferGeometry,o=i.geometry.getAttribute("position").array,h=i.geometry.getAttribute("normal").array,n=18*t,l=[],c=[],u=[];for(let r=0,a=i.segment;r<=a;++r){const p=r,g=r+t,d=g<=a?[[p,g,0]]:[[p,p+a-r,0],[0,g-a,a-r]],m=new s.Float32BufferAttribute(n,3),f=new s.Float32BufferAttribute(n,3);for(const[t,s,i]of d)e(3,t,s,o,m.array,i),e(3,t,s,h,f.array,i);l.push(m),c.push(f);const y=[],A=[];for(let t=0,s=i.segment;t<=s;++t)y.push(t/s*this.#dur),A.push(+(r===t));u.push(new s.KeyframeTrack(`.morphTargetInfluences[${r}]`,y,A,s.InterpolateDiscrete))}if(r.morphAttributes.position=l,r.morphAttributes.normal=c,r.setAttribute("position",l[0].clone()),r.setAttribute("normal",c[0].clone()),i.uv){const e=[];for(let s=0,r=t;s<=r;++s)e.push(i.uv(s,r));const o=new s.Float32BufferAttribute(12*t,2);for(let s=0;s<t;++s){const t=e[s].slice(0,2),i=e[s].slice(2,4),r=e[s+1].slice(0,2),h=e[s+1].slice(2,4);o.set([...t,...i,...r,...r,...i,...h],12*s)}r.setAttribute("uv",o)}this.#geom=r,this.#clip=new s.AnimationClip(void 0,this.#dur,u)}get strip(){return this.#strip}get geometry(){return this.#geom}get clip(){return this.#clip}get segment(){return this.#seg}get duration(){return this.#dur}dispose(){this.#strip=null,this.#geom?.dispose(),this.#geom=null,this.#clip=null,this.#seg=NaN,this.#dur=NaN}}}(s)):(i.#Helper=null,i.#Crv=null,i.#Anim=null)}static get Helper(){if(!this.#Helper)throw new s;return this.#Helper}static get Anim(){if(!this.#Anim)throw new s;return this.#Anim}static UvFns=[(t,s)=>[0,t/s,1,t/s],(t,s)=>[t/s,1,t/s,0],(t,s)=>[1,1-t/s,0,1-t/s],(t,s)=>[1-t/s,0,1-t/s,1]];#crv;#seg;#r=.5;#tilt=0;#uv;#mrps;#geom;#frms;#rFn=()=>.5;#tiltFn=()=>0;#disposed=!1;constructor(t,e,r=.5,o=0,h=null){if(!i.#THREE)throw new s;this.#crv=t,this.#seg=e,this.#setR(r),this.#setTilt(o),this.#uv=h,this.#mrps=null,this.#geom=null,this.#frms=null,this.#geom=new i.#THREE.BufferGeometry,this.#update()}#setR(t){this.#r=t,this.#rFn="function"==typeof t?t:()=>t}#setTilt(t){this.#tilt=t,this.#tiltFn="function"==typeof t?t:()=>t}get curve(){return this.#crv}set curve(t){this.#crv=t,this.#update()}get segment(){return this.#seg}set segment(t){(t=Math.max(1,0|t))!==this.#seg&&(this.#seg=t,this.#update())}get radius(){return this.#r}set radius(t){t!==this.#r&&(this.#setR(t),this.#update())}get tilt(){return this.#tilt}set tilt(t){t!==this.#tilt&&(this.#setTilt(t),this.#update())}get uv(){return this.#uv}set uv(t){t!==this.#uv&&(this.#uv=t,this.#update())}get geometry(){return this.#geom}get frames(){return this.#frms}setMorphs(t){this.#disposed||(this.#mrps=t,this.#update())}setProps(t=this.#crv,s=this.#seg,e=this.#r,i=this.#tilt,r=this.#uv){if(this.#disposed)return;const o=this.#crv!==t||this.#seg!==s||this.#r!==e||this.#tilt!==i||this.uv!==r;this.#crv=t,this.#seg=s,this.#setR(e),this.#setTilt(i),this.#uv=r,o&&this.#update()}dispose(){this.#disposed||(this.#crv=null,this.#seg=NaN,this.#r=NaN,this.#rFn=null,this.#tilt=NaN,this.#tiltFn=null,this.#uv=null,this.#mrps=null,this.#geom?.dispose(),this.#geom=null,this.#frms=null,this.#disposed=!0)}get isDisposed(){return this.#disposed}#update(){if(!i.THREE)return;if(this.#disposed||!this.#geom)return;this.#geom.dispose();const t=i.THREE,s=this.#geom,e=new t.Float32BufferAttribute(6*(this.#seg+1),3);s.setAttribute("position",e);const r=new t.Float32BufferAttribute(6*(this.#seg+1),3);s.setAttribute("normal",r);const o=[];this.#uv&&s.setAttribute("uv",new t.Float32BufferAttribute(4*(this.#seg+1),2));const h=s.getAttribute("uv");if(s.morphAttributes.position=[],s.morphAttributes.normal=[],!this.#crv)return this.#geom=null,void(this.#frms=null);this.#frms??=[],this.#frms.length=this.#seg;const n=this.#frms,l=new t.Vector3,c=new t.Vector3;let u=-1,a=NaN,p=NaN;if(i.#Crv.prototype.forEachTBN.call(this.#crv,this.#seg,((t,s)=>t/s),((t,s,[i,r,g],d)=>{a=this.#rFn(t,s),p=this.#tiltFn(t,s),n[t]??=[l,l,l],n[t][0]=i,n[t][1]=p?g.applyAxisAngle(i,p):g,n[t][2]=p?r.applyAxisAngle(i,p):r,l.copy(n[t][1]).multiplyScalar(a).add(d),c.copy(n[t][1]).multiplyScalar(-a).add(d),e.array.set([l.x,l.y,l.z,c.x,c.y,c.z],6*t),t<s&&o.push(u=2*t,u+1,u+2,u+2,u+1,u+3),this.#uv&&h.array.set(this.#uv(t,s),4*t)})),s.setIndex(o),1===this.#seg)l.addVectors(n[0][2],n[1][2]).divideScalar(2),r.array.set([l.x,l.y,l.z,l.x,l.y,l.z,l.x,l.y,l.z,l.x,l.y,l.z]);else for(const[t,s]of n.entries())0===t||t===n.length-1?r.array.set([s[2].x,s[2].y,s[2].z,s[2].x,s[2].y,s[2].z],6*t):(l.addVectors(n[t-1][2],s[2]).add(n[t+1][2]).divideScalar(3),r.array.set([l.x,l.y,l.z,l.x,l.y,l.z],6*t));if(this.#mrps)for(const{curve:t,radius:e,tilt:r}of this.#mrps){const{geometry:o}=new i(t,this.#seg,e,r);s.morphAttributes.position.push(o.getAttribute("position")),s.morphAttributes.normal.push(o.getAttribute("normal"))}}}export{i as Strip};
